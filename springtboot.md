# 分模块开发：

大家晚上好！今天我们开始本次的技术例会，本次例会的内容是讲解简单的springboot项目，是对的上次布置的题目进行修改优化。

关于如何新建项目和连接数据库在群里发的文件中有，这里就不多说了。直接开始讲解。

大家请看屏幕，在这个项目中，我们将其分成了mapper，service，controller、pojo四个部分。大家对这几个部分有多少了解，有没有人愿意说一下。

嗯，可以。说的很不错。之所以我们将其分为这几个部分是因为我们要将其进行业务分层，这对于代码规范是比较重要的，它决定后续代码是否可复用，是否职责清晰、边界清晰，方便我们进行项目的开发.

大家请看屏幕中的这张图

前端页面发送数据到后端服务器,后端接收前端传来到数据，也就是我们所说的请求，经过表现层、业务层、数据层这三层架构进行开发，最后在反着将数据转换为json形式返回给前端，这里的json数据是前后端数据交互的一种协议，可以理解为规定的一种标准格式让前后端都能用。

这里的表现层就是springMVC,Spring MVC呢是基于Servlet API构建的原始Web框架啊,这里不多说大家下去自己查查资料,它的作用是负责接收客户端请求，向客户端响应结果.然后就是业务层,它则负责处理业务规则和流程。服务层通常包含了一些复杂的业务逻辑,数据持久层就是和数据库交互，对数据库表进行曾删改查的。

好了,讲完这些,我们回到项目里面来.我们看见:

项目中的Controller层,就是MVC中的C--控制器,它作为应用程序的入口点，接收前端请求并调用Service业务逻辑层的业务逻辑进行处理。而Service层执行业务规则并调用Mapper层进行数据操作,Mapper层就是Mapper层是数据持久层的组件，负责与数据库进行交互。操作完之后将结果返回给Controller层。pojo这里则定义了与数据库表对应的属性及操作，这让我们可以更加方便地操作数据库表中的数据。

打开userController

我们定义了四个方法，uesr模块的增删改查操作，

我们来看第一个功能:增加数据操作,定义了一个返回类型为`Result`的方法,接收`User`对象,这里的`User对象`是使用`@RequestBody`将前端HTTP请求的JSON或XML数据转换为User对象,然后调用``userService`的`save()``方法,然后我们来到Service层来进行业务开发,通过声明的功能接口,我们来到其实现类中,

`UserController`中数据是如何访问，我们通过每个方法上面有一个字符串，这个就是对应操作的访问路径service层,通过接口,我们来到其实现类中,调用了`userMapper`的`insert()`方法，将传入的`user`对象插入到数据库中,最后我们来到Mapper层,对数据进行操作,通过MyBatis 的注解 `@Insert`，使用SQL语句将用户数据插入到数据表中.这样就完成了插入操作.



## controller控制层:

## 控制层是应用程序的入口点，它接收外部请求并根据请求的内容调用适当的服务来处理请求

@RestController：

> **它结合了 `@Controller` 和 `@ResponseBody` 注解的功能**它使得每个方法的返回值都会以 JSON 或 XML 的形式直接写入 HTTP 响应体中，也就是我们返回前端的数据

@Autowired：

> 直接应用于类的成员变量上。Spring 容器会自动为这些变量找到与其类型匹配的 Bean 实例，并进行注入。这样我们可以不需要手动创建实例对象，让代码更加简洁。
>
> * **控制器层**：在控制器层（Controller）中，需要注入服务层的Bean，以处理请求并返回响应。
>
> - **服务层**：在服务层（Service）中，通常需要依赖于数据访问层（Repository）的Bean，可以使用 `@Autowired` 注解来注入数据访问层的实例。
> - **依赖注入**：当一个Bean需要依赖于另一个Bean时，可以使用 `@Autowired` 注解来自动注入所需的Bean。

@PostMapping ：

> 它声明方法为 POST 请求处理方法，来处理客户端发送的 POST 请求，并且它自动将请求体中的数据转换为 Java 对象，并将返回值转换为 JSON 或 XML 格式，方便客户端解析处理。括号中的字符串就是操作的访问路径

@RequestBody：

> 来接收前端传递给后端的json字符串中的数据，将客户端发送的 JSON 或 XML 数据映射到 POJO（普通 Java 对象）上，也就是uesr里

@DeleteMapping

> 处理HTTP DELETE请求，并将请求映射到删除方法中

@PutMapping

> 将 HTTP PUT 请求映射到指定的处理方法上，将请求映射到具体的处理方法中

@GetMapping

> 它用于处理HTTP GET请求的方法，将请求映射到具体的处理方法中

@PathVariable

> 用于从请求路径中获取变量的值,就是我们前端传给我们的id，这里将路径中的一部分作为参数传递给方法.



#### POJO（数据层）：

> 简单无规则Java对象，只有属性+get+set方法，对应了数据库表的实体类。

@Data

> 生成getter,setter ,toString等函数

@NoArgsConstructor

> 生成无参构造函数

@AllArgsConstructor

> 生成全参数构造函数

## service业务逻辑层: 

> 服务层是应用程序的业务逻辑层，负责处理业务规则和流程。服务层通常包含了一些复杂的业务逻辑，例如数据校验、数据转换、事务管理等。服务层的主要作用是将控制器的请求转化为具体的业务操作，并协调多个持久层的操作来完成业务需求。
>
> service层=service接口+serviceImpl实现类；
>
> 专注业务逻辑，对于其中需要的数据库操作，都通过Mapper层去实现
>
> 接口还有接口的实现方法，在接口的实现方法中需要导入mapper层，mapper层是直接跟数据库打交道的，他也是个接口，只有方法名字，具体实现在mapper.xml文件里，service是供我们使用的方法。

@Service：

> 它是Spring Framework 中的一种注解，它标识了这个类是一个业务逻辑层的服务 Bean。

## mapper（DAO）数据持久层:

> 数据持久层，也叫持久层负责与数据存储相关的操作。比如访问数据库，向数据库发送sql语句，完成数据的增删改查任务等等。
>
> mybatis逆向工程生成的mapper层，其实就是dao层。
>
> 对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，而service层是针对我们controller，也就是针对我们使用者。
>
> service的impl是把mapper和service进行整合的文件



### impl:

> 为什么要有这个呢：根据软件设计的开闭原则，软件应该对修改关闭、对扩展开放。所以我们将Service类设计成一个接口，使控制层只依赖这个接口，于是就有了controller+service+serviceImpl，而Impl则去实现这个接口。













#### 进阶：

我们的程序按功能可以划分许多模块，

我们将原始模块按照功能拆分为若干个子模块，方便模块间的相互调用，进行接口的共享。
